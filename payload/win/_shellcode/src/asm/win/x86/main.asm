; main.asm; Call MessageBox
; Reference:
; https://mohamed-fakroud.gitbook.io/red-teamings-dojo/shellcoding/leveraging-from-pe-parsing-technique-to-write-x86-shellcode
BITS 32

section .text
global _start

_start:
    ; Get the address of the kernel32.dll
    xor eax, eax                ; Avoid null bytes
    mov eax, [fs:eax + 0x30]    ; TEB->PEB
    mov eax, [eax + 0xc]        ; PEB->Ldr (PEB_LDR_DATA)
    mov esi, [eax + 0x14]       ; Ldr->Ldr.InMemoryOrderModuleList
    lodsd                       ; Move to the next element -> InMemoryOrderLinks of ntdll.dll (second module)
    xchg eax, esi               ; Exchange eax and esi
    lodsd                       ; Move to the next element -> InMemoryOrderLinks of kernel32.dll (third module)
    mov eax, [eax + 0x10]       ; The base address of kernel32.dll

    ; Parse the PE file and find the Export Directory
    mov ebx, [eax + 0x3c]       ; RVA (Relative Virtual Address) of PE signature (the 'e_lfanew' pointer at the offset 0x3c)
    add ebx, eax                ; VA (Virtual Address) of PE signature
    mov ebx, [ebx + 0x78]       ; RVA of the Export Directory (IMAGE_EXPORT_DIRECTORY)
    add ebx, eax                ; VA of the Export Directory
    mov esi, [ebx + 0x20]       ; RVA of the exported function names table (AddressOfNames)
    add esi, eax                ; VA of the exported function names table
    mov edx, eax                ; Save eax which holds the kernel32.dll address into edx for using the value later
    push esi
    
    ; Find the address of LoadLibraryA
    push 0x00059ba3             ; The hash value of 'LoadLibraryA' (generated by 'dll_hash_calc')
    xor ecx, ecx                ; Init counter by setting ecx to 0
    call find_addr
    call get_addr
    push edi

    ; Restore VA of the exported function names table
    mov esi, [esp + 8]

    ; Find the address of GetProcAddress
    push 0x0015bdfd             ; The hash value of 'GetProcAddress' (generated by 'dll_hash_calc')
    xor ecx, ecx
    mov esi, [esp + 8]
    call find_addr
    call get_addr
    push edi

    jmp do_main

find_addr:
    inc ecx
    lodsd               ; Load name RVA into eax and increment esi by 4 to the next RVA
    add eax, edx        ; Add kernel32 base address to get VA of the function name
    call calc_hash
    cmp edi, [esp + 4]  ; Compare if the value stored in 'edi' match the hash of LoadLibraryA which already pushed on the stack
    jnz find_addr
    ret

calc_hash:
    push ecx        ; Save ecx on the stack for using the value after
    push edx        ; Save edx on the stack for using the value after

    xor ecx, ecx    ; Clear ecx, edi and edx
    mov edi, ecx
    mov edx, edi

    _loop:
        shl edi, 1
        mov dl, BYTE [eax + ecx]
        add edi, edx
        inc ecx
        cmp BYTE[eax + ecx], 0  ; Check if the counter (ecx) reaches the final character (null-terminated string)
        jne _loop               ; If so the loop ends, otherwise the loop continues

    pop edx
    pop ecx
    ret

get_addr:
    mov esi, [ebx + 0x24]       ; RVA of function ordinal table (AddressOfNameOrdinals)
    add esi, edx                ; VA of function ordinal table
    mov cx, WORD[esi + ecx * 2] ; Get LoadLibraryA biased_ordinal
    dec ecx                     ; Get LoadLibraryA ordinal
    mov esi, [ebx + 0x1c]       ; RVA of Export Address Table (AddressOfFunctions)
    add esi, edx                ; VA of the Exported Table
    mov edi, [esi + ecx * 4]    ; RVA of LoadLibraryA
    add edi, edx                ; VA of LoadLibraryA
    ret

do_main:
    ; Load user32.dll by calling LoadLibraryA("user32.dll")
    mov edi, [esp + 8]
    push "ll"
    push "32.d"
    push "user"
    push esp                ; Push esp which contains the string "user32.dll" on the stack
    call edi

    ; Get the address of MessageBoxA by calling GetProcAddress(user32.dll, "MessageBoxA")
    push "oxA"
    push "ageB"
    push "Mess"
    push esp                ; Push esp which contains the string "MessageBoxA" on the stack
    push eax                ; Push eax which contains the user32.dll base address on the stack
    mov edi, [esp + 32]
    call edi

    ; Prepare the string for the arguments of MessageBoxA
    push "3w"
    push "T3nb"
    mov esi, esp

    ; Call MessageBoxA(NULL, "T3nb3w", "T3nb3w", MB_OK)
    xor ebx, ebx
    push ebx                ; MB_OK = 0x00000000L
    push esi                ; L"T3nb3w"
    push esi                ; L"T3nb3w"
    push ebx                ; NULL
    call eax
